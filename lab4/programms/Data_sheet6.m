%Программа приведения матрицы к верхней почти
%треугольной форме методом отражения
%очищаем рабочее пространство
clear all
%определяем максимальный порядок матрицы
nmax=403;
%организуем цикл преобразований матриц разного
%порядка
for n=3:20:nmax
    %запоминаем начало работы процессора при
    %преобразовании матрицы
    t0=cputime;
    %создаем случайную матрицу
    A=randn(n);
    %определяем цикл q-2 подобных
    %преобразований отражения
    for q=1:(n-2)
        u=0;
        for i=(q+1):n
            u=u+abs(A(i,q))^2;
        end
        %согласно теории вычисляем b(q+1,q)
        bq1q=sqrt(u);
        alpha=sqrt(2*bq1q*(bq1q+abs(A(q+1,q))));
        %формируем вектор нормали w к плоскости
        %отражения
        w=zeros(n,1);
        w(q+1)=(A(q+1,q)+bq1q*sign(A(q+1,q)))/alpha;
        for i=(q+2):n
            w(i)=A(i,q)/alpha;
        end
        %вычисляем матрицу отражения R при текущем
        %значении вектора w
        for i=1:n
            for j=1:n
                if i==j
                    R(i,j)=1-2*w(i)*w(j);
                else
                    R(i,j)=-2*w(i)*w(j);
                end
            end
        end
        %осуществляем подобное преобразование матрицы A
        %с помощью матрицы отражения R
        B=R*A*R;
        A=B;
    end
    %определяем время потраченное центральным процессором
    %на преобразование матрицы A к верхнему почти
    %треугольному виду методом отражения
    t(n)=cputime-t0;
    %аналогичную процедуру оценки времени центрального
    %процессора проводим при использовании разложения
    %Хессенберга с помощью функции hess
    t0=cputime;
    B=hess(randn(n));
    thess(n)=cputime-t0;
end
%рисуем в одном окне график зависимости времени работы
%центрального процессора по преобразованию матрицы от
%порядка матрицы для нашей программы (маркер *) и для
%встроенной в MATLAB программы hess (марке "пентаграмма")
semilogy(3:20:nmax,t([3:20:nmax]),'-*',...
         3:20:nmax,thess([3:20:nmax]),'-p');