clear; clc; % очистка командного окна и переменных
% Определение функции для решаемого уравнения
f = @(x) 2 * exp(-3 * x) - 3 * x + 2;

% Определение интервала для перебора корней
a = 0; % начало интервала
b = 1; % конец интервала
n = 1000; % количество точек для перебора

x0 = 0; % Начальное приближение
x_fzero = fzero(f, x0);
disp(['fzero solution: x = ', num2str(x_fzero)]);
fprintf('-------------------------\n\n');
% Использование fsolve для нахождения корня
x_fsolve = fsolve(f, x0);
disp(['fsolve solution: x = ', num2str(x_fsolve)]);
fprintf('-------------------------\n\n');
x0 = 0; % Начальное приближение
x_fzero = fzero(f, x0);
disp(['fzero solution: x = ', num2str(x_fzero)]);
fprintf('-------------------------\n\n');
% Использование fsolve для нахождения корня
x_fsolve = fsolve(f, x0);
disp(['fsolve solution: x = ', num2str(x_fsolve)]);
fprintf('-------------------------\n\n');


% Метод перебора
x = linspace(a, b, n); % генерация n равномерно распределенных точек на интервале [a, b]
y = f(x); % вычисление значений функции в этих точках
roots = x(abs(y) < 0.01); % выбор корней с определенной точностью

% Результаты перебора
disp(' ');
fprintf('-------------------------\n\n');
fprintf('Метод перебора:\n');
fprintf('Корни уравнения: ');
disp(roots);
fprintf('-------------------------\n\n');

% График функции и найденных корней
figure;
plot(x, y, 'b'); % построение графика функции
hold on;
plot(roots, f(roots), 'm*'); % отметка корней на графике
xlabel('x');
ylabel('f(x)');
title('График функции и найденных корней');
legend('Функция f(x)', 'Корни', 'Location', 'NorthWest');


fprintf('Метод половинного деления:\n');
% Проверка сходимости метода половинного деления

% Интервал начального приближения a и b
a = -1;
b = 1;
tol = 1e-6;
maxIter = 1000;

% Проверка условия сходимости
converge = true; % предполагаем, что сходится
iter = 0;
if f(a) * f(b) > 0
    converge = false; % не сходится
end

while abs(f(a) * f(b)) > tol && iter < maxIter
    c = (a + b) / 2;
    if f(a) * f(c) < 0
        b = c;
    else
        a = c;
    end
    iter = iter + 1;
end

fprintf('Сходимость метода: %d (1 - сходится, 0 - не сходится)\n', converge);


% Метод половинного деления
a = -1; 
b = 1; 
tol = 1e-6; % Точность
maxIter = 1000; % Максимальное количество итераций

if f(a) * f(b) > 0
    error('Условие сходимости не выполнено. Выберите другой интервал.');
end

c = (a + b) / 2;  % Начальное приближение

iter = 0;
while abs(f(c)) > tol && iter < maxIter
    if f(a) * f(c) < 0
        b = c;
    else
        a = c;
    end
    c = (a + b) / 2;
    iter = iter + 1;
end
fprintf('Корень: %f \nЧисло итераций: %d\n\n', c, iter);
fprintf('-------------------------\n\n');
% Проверка сходимости метода простых итераций
% Производная функции g(x)
dg = @(x) (3 / (3 * x - 2));

% Проверка условия сходимости |g'(x)| < 1 в окрестности корня
x = 1.8; % Выбор начального значения x в окрестности корня

maxIter = 100; % Максимальное количество итераций

% Проверка условия сходимости
converge = true; % предполагаем, что сходится
iter = 0;
while abs(dg(x)) >= 1 && iter < maxIter
    x = g(x);
    iter = iter + 1;
end
if abs(dg(x)) >= 1
    converge = false; % не сходится
end
fprintf('Метод простых итераций:\n');
fprintf('Сходимость метода: %d (1 - сходится, 0 - не сходится)\n', converge);

% Метод простых итераций
g = @(x) log((3 * x - 2) / 2);
x0 = 0; % Начальное приближение
tol = 1e-6; % Точность
maxIter = 100; % Максимальное количество итераций

iter = 0;
while iter < maxIter
    x = g(x0);
    if abs(x - x0) < tol
        break;
    end
    x0 = x;
    iter = iter + 1;
end
fprintf('Корень: %f\nЧисло итераций: %d\n', x, iter);
fprintf('-------------------------\n\n');

% Проверка сходимости метода хорд

% Начальные приближения x0 и x1
x0 = -1;
x1 = 1;
tol = 1e-6; % Точность
maxIter = 100; % Максимальное количество итераций

% Проверка условия сходимости
converge = true; % предполагаем, что сходится
iter = 0;
while abs(x1 - x0) >= tol && iter < maxIter
    x = x1 - (f(x1) * (x1 - x0)) / (f(x1) - f(x0));
    if abs(x - x1) < tol
        break;
    end
    x0 = x1;
    x1 = x;
    iter = iter + 1;
end
if dg(x) < 0
    converge = false; % не сходится
end
fprintf('Метод хорд:\n');
fprintf('Сходимость метода: %d (1 - сходится, 0 - не сходится)\n', converge);

% Метод хорд
x0 = 0; % Начальное приближение
x1 = 1; % Второе начальное приближение
tol = 1e-6; % Точность
maxIter = 100; % Максимальное количество итераций

iter = 0;
while iter < maxIter
    x = x1 - (f(x1) * (x1 - x0)) / (f(x1) - f(x0));
    if abs(x - x1) < tol
        break;
    end
    x0 = x1;
    x1 = x;
    iter = iter + 1;
end
fprintf('Корень %f\nЧисло итераций: %d\n', x, iter);
fprintf('-------------------------\n\n');

% Проверка сходимости метода секущих

% Начальные приближения x0 и x1
x0 = -1;
x1 = 1;
tol = 1e-6; % Точность
maxIter = 100; % Максимальное количество итераций

% Проверка условия сходимости
converge = true; % предполагаем, что сходится
iter = 0;
while abs(x1 - x0) >= tol && iter < maxIter
    x = x1 - (f(x1) * (x1 - x0)) / (f(x1) - f(x0));
    if abs(x - x1) < tol
        break;
    end
    x0 = x1;
    x1 = x;
    iter = iter + 1;
end
if dg(x) < 0
    converge = false; % не сходится
end
fprintf('Метод секущих:\n');
fprintf('Сходимость метода: %d (1 - сходится, 0 - не сходится)\n', converge);

% Метод секущих
x0 = -1; % Начальное приближение 1
x1 = 1; % Начальное приближение 2
tol = 1e-6; % Точность
maxIter = 100; % Максимальное количество итераций

iter = 0;
while iter < maxIter
    x = x1 - (f(x1) * (x1 - x0)) / (f(x1) - f(x0));
    if abs(x - x1) < tol
        break;
    end
    x0 = x1;
    x1 = x;
    iter = iter + 1;
end
fprintf('Корень %f\nЧисло итераций: %d\n', x, iter);
fprintf('-------------------------\n\n');


